# Project Title

HGS with customer profits

## Dependencies

Building PC-HGS requires

* cmake >= 3.14
* A compiler with C++-20 support

## Installation

1. Clone the repository and initialize submodules.

```bash
  git clone https://oscm.maximilian-schiffer.com/euro-neurips22/pchgs/
  cd pchgs
  git submodule update --init --recursive
```

2. Generate a makefile

```bash
mkdir build
cd build
cmake .. -DCMAKE_BUILD_TYPE="RELEASE"
```

Support build types: RELEASE, DEBUG, RELWITHDEBINFO

3. Build

```bash
make
```

## Usage/Examples

#### Get usage

```bash
./pchgs -h
```

#### Solving instances

```bash
./pchgs instance.json <time_limit> -seed <seed> -veh -1 -useWallClockTime 1 -outputJSONPath solution.json
```

Runs pchgs on instance.json, with the time limit `<time_limit>` (seconds, wall clock time), an infinite number of
vehicles. The final solution will be output to `solution.json` in json format:

```json
{
  // Cost of the solution (includes profit).
  "cost": 1000,
  // Ignore, currently always 0
  "prize": 0,
  "routes": [
    {
      // Ignore, currently always 0
      "cost": 0,
      // Ignore, currently always 0
      "prize": 0,
      "requests": [
        // Depot is not included! request_idx is the request_idx given in the instance (see below)
        request_idx_of_first_customer_in_route,
        request_idx_of_second_customer_in_route,
        ...
      ]
    },
    ...
  ]
}
```

#### Instance format

In the instances we consider (i.e., the ones generated by the python solver) we scale all values except coodinates by
100 and round to integers.

Hence, **all** non-coordinate values in the instance file must be given as **integers**, obtained
through `int(value * 100.0)`.

Please **always** give prices when possible. This boosts the performance of the heuristic!

**VRPLIB format:**

Two additional sections: `EDGE_COST_SECTION` and `PROFIT_SECTION`.
The `EDGE_COST_SECTION` is formatted just like the `EDGE_WEIGHT_SECTION` and gives the cost of arc (i,j) for each pair
of nodes i and j.
The `PROFIT_SECTION` is formatted like the `SERVICE_TIME` section and gives, for each node, the associated profit.

**JSON format:**

```json
{
  "capacity": 0,
  "nodes": [
    {
      "coords": [
        0,
        0
      ],
      "service_time": 0,
      "demand": 0,
      "time_window": [
        0,
        0
      ],
      "release_time": 0,
      // Optional
      "profit": 0,
      "request_idx": 0
      // Request ID to tie node to. Used in output. Just set to index if no naming is required.
    }
  ],
  "durations": [
    // Travel time of first node to all other nodes.
    // Does not use request_idx, but the index of the customer in the nodes list.
    [
      ...
    ],
    // Travel time of second node to all other nodes.
    // Does not use request_idx, but the index of the customer in the nodes list.
    [
      ...
    ],
    ...
  ],
  "cost": [
    // Cost of travelling from the first node to all other nodes.
    // Does not use request_idx, but the index of the customer in the nodes list.
    [
      ...
    ],
    // Cost of travelling from the second node to all other nodes.
    // Does not use request_idx, but the index of the customer in the nodes list.
    [
      ...
    ],
    ...
  ]
}
```

#### Warmstarting

The solver supports warm starting with previously found solutions. These have to have the same number of customers with the same request ids. Anything else (i.e., prices and distances) may vary. To warm start, simply pass the filenames of previous solutions on the command line:

```
./pchgs ... -seedSolutions "first-solution.json,second-solution.json"
```

Solutions should be separated by `,`. Relative paths will be interpreted relative to the current working directory at the time of execution.
